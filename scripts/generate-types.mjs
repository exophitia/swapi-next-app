/**
 * Fetches sample responses from SWAPI per resource, saves to samples/,
 * then runs quicktype to generate TypeScript types to lib/types/.
 * Run: npm run generate:types
 */
import { mkdir, writeFile, readFile } from "fs/promises";
import { execSync } from "child_process";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const ROOT = path.resolve(__dirname, "..");
const SWAPI_BASE = "https://swapi.py4e.com/api";
const SAMPLES_DIR = path.join(ROOT, "samples");
const TYPES_DIR = path.join(ROOT, "lib", "types");

function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

async function main() {
  const res = await fetch(`${SWAPI_BASE}/`);
  const data = await res.json();

  await mkdir(SAMPLES_DIR, { recursive: true });
  await mkdir(TYPES_DIR, { recursive: true });

  const headerLines = [
    "// AUTO-GENERATED BY scripts/generate-types.mjs. DO NOT EDIT BY HAND.",
    "// Run `npm run generate:types` to regenerate.",
    "",
  ];
  const header = headerLines.join("\n");

  // Root-Response speichern und Typen für die Übersicht generieren
  const rootSamplePath = path.join(SAMPLES_DIR, "root.json");
  await writeFile(rootSamplePath, JSON.stringify(data, null, 2), "utf-8");

  const rootOutPath = path.join(TYPES_DIR, "root.ts");
  execSync(
    `npx quicktype "${rootSamplePath}" -o "${rootOutPath}" --just-types --top-level SwapiRoot`,
    { stdio: "inherit", cwd: ROOT }
  );
  const rootContent = await readFile(rootOutPath, "utf-8");
  await writeFile(rootOutPath, `${header}${rootContent}`, "utf-8");

  const keys = Object.keys(data).filter(
    (k) => typeof data[k] === "string" && data[k].startsWith("http")
  );

  for (const resource of keys) {
    let item = null;
    const itemRes = await fetch(`${SWAPI_BASE}/${resource}/1/`);
    if (itemRes.ok) {
      item = await itemRes.json();
    } else {
      const listRes = await fetch(`${SWAPI_BASE}/${resource}/?page=1`);
      if (!listRes.ok) continue;
      const list = await listRes.json();
      const results = list.results || [];
      if (results.length === 0) continue;
      const firstUrl = results[0].url;
      const singleRes = await fetch(firstUrl);
      if (!singleRes.ok) continue;
      item = await singleRes.json();
    }
    const samplePath = path.join(SAMPLES_DIR, `${resource}.json`);
    await writeFile(samplePath, JSON.stringify(item, null, 2), "utf-8");

    const typeName = capitalize(resource);
    const outPath = path.join(TYPES_DIR, `${resource}.ts`);
    execSync(
      `npx quicktype "${samplePath}" -o "${outPath}" --just-types --top-level ${typeName}`,
      { stdio: "inherit", cwd: ROOT }
    );
    const typeContent = await readFile(outPath, "utf-8");
    await writeFile(outPath, `${header}${typeContent}`, "utf-8");
  }

  // Build a central index.ts that re-exports all resource types and helper unions.
  const typeNames = keys.map((resource) => capitalize(resource));

  const indexLines = [
    ...headerLines,
    ...keys.map(
      (resource, idx) =>
        `export type { ${typeNames[idx]} } from "./${resource}";`
    ),
    'export type { SwapiRoot } from "./root";',
    "",
    ...keys.map(
      (resource, idx) =>
        `import type { ${typeNames[idx]} } from "./${resource}";`
    ),
    'import type { SwapiRoot } from "./root";',
    "",
    "/** Union of all SWAPI resource item types (single entity from API). */",
    "export type SwapiResourceItem =",
    "  | " + typeNames.join("\n  | ") + ";",
    "",
    "/** Resource keys that have a list endpoint and detail endpoint. */",
    "export type SwapiResourceKey = keyof SwapiRoot;",
    "",
  ];

  await writeFile(
    path.join(TYPES_DIR, "index.ts"),
    indexLines.join("\n"),
    "utf-8"
  );

  console.log("Types generated in lib/types/");
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});
