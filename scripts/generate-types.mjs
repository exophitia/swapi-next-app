/**
 * Script for generating strongly-typed TypeScript definitions from SWAPI.
 *
 * High-level flow:
 * 1. Fetch the SWAPI root endpoint to discover all available resources.
 * 2. Persist the root response to `samples/root.json` and generate `lib/types/root.ts`.
 * 3. For every discovered resource (people, planets, …),
 *    fetch a representative item, store it under `samples/<resource>.json`,
 *    and run `quicktype` to create `lib/types/<resource>.ts`.
 * 4. Build a central `lib/types/index.ts` that re-exports all resource types
 *    and defines helper unions such as `SwapiResourceItem` and `SwapiResourceKey`.
 *
 * Run via: `npm run generate:types`
 */
import { mkdir, writeFile, readFile } from "fs/promises";
import { execSync } from "child_process";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Absolute path to the project root (one level above this script).
 * All relative output paths are resolved against this directory.
 */
const ROOT = path.resolve(__dirname, "..");

/**
 * Base URL of the SWAPI instance that is used for all HTTP requests.
 * If you ever want to point to a different SWAPI mirror, change it here.
 */
const SWAPI_BASE = "https://swapi.py4e.com/api";

/**
 * Folder where the raw JSON samples from SWAPI are stored.
 * These are useful for debugging and for re-running quicktype manually.
 */
const SAMPLES_DIR = path.join(ROOT, "samples");

/**
 * Folder that contains all generated TypeScript definition files.
 * The script will ensure this directory exists before writing.
 */
const TYPES_DIR = path.join(ROOT, "lib", "types");

/**
 * Turns a resource key such as "people" or "starships" into a type-friendly
 * PascalCase name ("People", "Starships"). This is used as the top-level
 * type name when calling quicktype.
 */
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/** SWAPI fields that can be null in the API (e.g. Droid has no homeworld). */
const NULLABLE_STRING_KEYS = new Set(["homeworld"]);

/**
 * Converts a plain JSON value to Zod schema source code (string).
 * Used to generate lib/swapi-schemas.ts from the same samples as the types.
 * @param {unknown} value - JSON value
 * @param {string} [objectKey] - Key when value is inside an object (used for .nullable())
 */
function jsonToZodSchema(value, objectKey = "") {
  if (value === null) return "z.null()";
  if (typeof value === "string") {
    return NULLABLE_STRING_KEYS.has(objectKey) ? "z.string().nullable()" : "z.string()";
  }
  if (typeof value === "number") return "z.number()";
  if (typeof value === "boolean") return "z.boolean()";
  if (Array.isArray(value)) {
    const first = value[0];
    const itemSchema =
      first !== undefined ? jsonToZodSchema(first) : "z.string()";
    return `z.array(${itemSchema})`;
  }
  if (typeof value === "object") {
    const entries = Object.entries(value).map(([k, v]) => {
      const safeKey = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k) ? k : JSON.stringify(k);
      return `${safeKey}: ${jsonToZodSchema(v, k)}`;
    });
    return `z.object({ ${entries.join(", ")} })`;
  }
  return "z.unknown()";
}

/**
 * Main entry point: orchestrates fetching, sampling and type generation.
 *
 * It is intentionally written as a single sequential flow so that it is easy
 * to follow when something goes wrong (e.g. network errors or SWAPI changes).
 */
async function main() {
  // 1) Discover all available resources via the SWAPI root endpoint.
  const res = await fetch(`${SWAPI_BASE}/`);
  const data = await res.json();

  // Ensure that the output directories exist before we start writing files.
  await mkdir(SAMPLES_DIR, { recursive: true });
  await mkdir(TYPES_DIR, { recursive: true });

  // Common header that is prepended to every generated .ts file so humans
  // immediately see that they should not edit these files manually.
  const headerLines = [
    "// AUTO-GENERATED BY scripts/generate-types.mjs. DO NOT EDIT BY HAND.",
    "// Run `npm run generate:types` to regenerate.",
    "",
  ];
  const header = headerLines.join("\n");

  // 2) Store root response and generate types for the overview.
  const rootSamplePath = path.join(SAMPLES_DIR, "root.json");
  await writeFile(rootSamplePath, JSON.stringify(data, null, 2), "utf-8");

  const rootOutPath = path.join(TYPES_DIR, "root.ts");
  execSync(
    `npx quicktype "${rootSamplePath}" -o "${rootOutPath}" --just-types --top-level SwapiRoot --no-date-times`,
    { stdio: "inherit", cwd: ROOT }
  );
  const rootContent = await readFile(rootOutPath, "utf-8");
  await writeFile(rootOutPath, `${header}${rootContent}`, "utf-8");

  // Extract all resource keys that look like list endpoints (only string URLs).
  const keys = Object.keys(data).filter(
    (k) => typeof data[k] === "string" && data[k].startsWith("http")
  );

  // 3) For each resource, fetch a representative single entity sample.
  for (const resource of keys) {
    let item = null;

    // Preferred path: try to fetch `/resource/1/` directly (most SWAPI
    // resources expose this and it is cheap).
    const itemRes = await fetch(`${SWAPI_BASE}/${resource}/1/`);
    if (itemRes.ok) {
      item = await itemRes.json();
    } else {
      // Fallback path for resources where `/1/` is not valid:
      // - fetch the first page of the list,
      // - pick the first result,
      // - follow its `url` to get a canonical single-entity response.
      const listRes = await fetch(`${SWAPI_BASE}/${resource}/?page=1`);
      if (!listRes.ok) continue;
      const list = await listRes.json();
      const results = list.results || [];
      if (results.length === 0) continue;
      const firstUrl = results[0].url;
      const singleRes = await fetch(firstUrl);
      if (!singleRes.ok) continue;
      item = await singleRes.json();
    }
    // Persist the chosen sample so we can inspect it or regenerate types later.
    const samplePath = path.join(SAMPLES_DIR, `${resource}.json`);
    await writeFile(samplePath, JSON.stringify(item, null, 2), "utf-8");

    const typeName = capitalize(resource);
    const outPath = path.join(TYPES_DIR, `${resource}.ts`);
    execSync(
      `npx quicktype "${samplePath}" -o "${outPath}" --just-types --top-level ${typeName} --no-date-times`,
      { stdio: "inherit", cwd: ROOT }
    );
    let typeContent = await readFile(outPath, "utf-8");
    typeContent = typeContent.replace(
      /homeworld:\s*string;/g,
      "homeworld: string | null;"
    );
    await writeFile(outPath, `${header}${typeContent}`, "utf-8");
  }

  // 4) Build a central index.ts that re-exports all resource types and helper unions.
  const typeNames = keys.map((resource) => capitalize(resource));

  const indexLines = [
    ...headerLines,
    ...keys.map(
      (resource, idx) =>
        `export type { ${typeNames[idx]} } from "./${resource}";`
    ),
    'export type { SwapiRoot } from "./root";',
    "",
    ...keys.map(
      (resource, idx) =>
        `import type { ${typeNames[idx]} } from "./${resource}";`
    ),
    'import type { SwapiRoot } from "./root";',
    "",
    "/** Union of all SWAPI resource item types (single entity from the API). */",
    "export type SwapiResourceItem =",
    "  | " + typeNames.join("\n  | ") + ";",
    "",
    "/** Resource keys that have both a list endpoint and a detail endpoint. */",
    "export type SwapiResourceKey = keyof SwapiRoot;",
    "",
  ];

  await writeFile(
    path.join(TYPES_DIR, "index.ts"),
    indexLines.join("\n"),
    "utf-8"
  );

  // 5) Generate Zod schemas from the same samples (all fields as in the types).
  const LIB_DIR = path.join(ROOT, "lib");
  const swapiRootSchemaCode = jsonToZodSchema(data);

  const itemSchemaCodes = [];
  for (const resource of keys) {
    const samplePath = path.join(SAMPLES_DIR, `${resource}.json`);
    const raw = await readFile(samplePath, "utf-8");
    const item = JSON.parse(raw);
    itemSchemaCodes.push(jsonToZodSchema(item));
  }
  const resultsSchemaCode = `z.array(z.union([${itemSchemaCodes.join(", ")}]))`;
  const resourcePageResponseSchemaCode =
    `z.object({ count: z.number(), next: z.string().nullable(), previous: z.string().nullable(), results: ${resultsSchemaCode} })`;

  const schemasLines = [
    ...headerLines,
    'import { z } from "zod";',
    "",
    "/** Root SWAPI response (resource keys → URLs). Generated from samples/root.json */",
    `export const swapiRootSchema = ${swapiRootSchemaCode};`,
    "",
    "/** Paginated list response. Used to validate getResourcePage() responses. */",
    `export const resourcePageResponseSchema = ${resourcePageResponseSchemaCode};`,
    "",
  ];

  await writeFile(
    path.join(LIB_DIR, "swapi-schemas.ts"),
    schemasLines.join("\n"),
    "utf-8"
  );

  console.log("Types generated in lib/types/");
  console.log("Zod schemas generated in lib/swapi-schemas.ts");
}

main().catch((err) => {
  // Make the script fail fast in CI or npm scripts when something goes wrong.
  console.error(err);
  process.exit(1);
});
