/**
 * Script for generating strongly-typed TypeScript definitions from SWAPI.
 *
 * High-level flow:
 * 1. Fetch the SWAPI root endpoint to discover all available resources.
 * 2. Persist the root response to `samples/root.json` and generate `lib/types/root.ts`.
 * 3. For every discovered resource (people, planets, â€¦),
 *    fetch a representative item, store it under `samples/<resource>.json`,
 *    and run `quicktype` to create `lib/types/<resource>.ts`.
 * 4. Build a central `lib/types/index.ts` that re-exports all resource types
 *    and defines helper unions such as `SwapiResourceItem` and `SwapiResourceKey`.
 *
 * Run via: `npm run generate:types`
 */
import { mkdir, writeFile, readFile } from "fs/promises";
import { execSync } from "child_process";
import { fileURLToPath } from "url";
import path from "path";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Absolute path to the project root (one level above this script).
 * All relative output paths are resolved against this directory.
 */
const ROOT = path.resolve(__dirname, "..");

/**
 * Base URL of the SWAPI instance that is used for all HTTP requests.
 * If you ever want to point to a different SWAPI mirror, change it here.
 */
const SWAPI_BASE = "https://swapi.py4e.com/api";

/**
 * Folder where the raw JSON samples from SWAPI are stored.
 * These are useful for debugging and for re-running quicktype manually.
 */
const SAMPLES_DIR = path.join(ROOT, "samples");

/**
 * Folder that contains all generated TypeScript definition files.
 * The script will ensure this directory exists before writing.
 */
const TYPES_DIR = path.join(ROOT, "lib", "types");

/**
 * Turns a resource key such as "people" or "starships" into a type-friendly
 * PascalCase name ("People", "Starships"). This is used as the top-level
 * type name when calling quicktype.
 */
function capitalize(s) {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Main entry point: orchestrates fetching, sampling and type generation.
 *
 * It is intentionally written as a single sequential flow so that it is easy
 * to follow when something goes wrong (e.g. network errors or SWAPI changes).
 */
async function main() {
  // 1) Discover all available resources via the SWAPI root endpoint.
  const res = await fetch(`${SWAPI_BASE}/`);
  const data = await res.json();

  // Ensure that the output directories exist before we start writing files.
  await mkdir(SAMPLES_DIR, { recursive: true });
  await mkdir(TYPES_DIR, { recursive: true });

  // Common header that is prepended to every generated .ts file so humans
  // immediately see that they should not edit these files manually.
  const headerLines = [
    "// AUTO-GENERATED BY scripts/generate-types.mjs. DO NOT EDIT BY HAND.",
    "// Run `npm run generate:types` to regenerate.",
    "",
  ];
  const header = headerLines.join("\n");

  // 2) Store root response and generate types for the overview.
  const rootSamplePath = path.join(SAMPLES_DIR, "root.json");
  await writeFile(rootSamplePath, JSON.stringify(data, null, 2), "utf-8");

  const rootOutPath = path.join(TYPES_DIR, "root.ts");
  execSync(
    `npx quicktype "${rootSamplePath}" -o "${rootOutPath}" --just-types --top-level SwapiRoot`,
    { stdio: "inherit", cwd: ROOT }
  );
  const rootContent = await readFile(rootOutPath, "utf-8");
  await writeFile(rootOutPath, `${header}${rootContent}`, "utf-8");

  // Extract all resource keys that look like list endpoints (only string URLs).
  const keys = Object.keys(data).filter(
    (k) => typeof data[k] === "string" && data[k].startsWith("http")
  );

  // 3) For each resource, fetch a representative single entity sample.
  for (const resource of keys) {
    let item = null;

    // Preferred path: try to fetch `/resource/1/` directly (most SWAPI
    // resources expose this and it is cheap).
    const itemRes = await fetch(`${SWAPI_BASE}/${resource}/1/`);
    if (itemRes.ok) {
      item = await itemRes.json();
    } else {
      // Fallback path for resources where `/1/` is not valid:
      // - fetch the first page of the list,
      // - pick the first result,
      // - follow its `url` to get a canonical single-entity response.
      const listRes = await fetch(`${SWAPI_BASE}/${resource}/?page=1`);
      if (!listRes.ok) continue;
      const list = await listRes.json();
      const results = list.results || [];
      if (results.length === 0) continue;
      const firstUrl = results[0].url;
      const singleRes = await fetch(firstUrl);
      if (!singleRes.ok) continue;
      item = await singleRes.json();
    }
    // Persist the chosen sample so we can inspect it or regenerate types later.
    const samplePath = path.join(SAMPLES_DIR, `${resource}.json`);
    await writeFile(samplePath, JSON.stringify(item, null, 2), "utf-8");

    const typeName = capitalize(resource);
    const outPath = path.join(TYPES_DIR, `${resource}.ts`);
    execSync(
      `npx quicktype "${samplePath}" -o "${outPath}" --just-types --top-level ${typeName}`,
      { stdio: "inherit", cwd: ROOT }
    );
    const typeContent = await readFile(outPath, "utf-8");
    await writeFile(outPath, `${header}${typeContent}`, "utf-8");
  }

  // 4) Build a central index.ts that re-exports all resource types and helper unions.
  const typeNames = keys.map((resource) => capitalize(resource));

  const indexLines = [
    ...headerLines,
    ...keys.map(
      (resource, idx) =>
        `export type { ${typeNames[idx]} } from "./${resource}";`
    ),
    'export type { SwapiRoot } from "./root";',
    "",
    ...keys.map(
      (resource, idx) =>
        `import type { ${typeNames[idx]} } from "./${resource}";`
    ),
    'import type { SwapiRoot } from "./root";',
    "",
    "/** Union of all SWAPI resource item types (single entity from the API). */",
    "export type SwapiResourceItem =",
    "  | " + typeNames.join("\n  | ") + ";",
    "",
    "/** Resource keys that have both a list endpoint and a detail endpoint. */",
    "export type SwapiResourceKey = keyof SwapiRoot;",
    "",
  ];

  await writeFile(
    path.join(TYPES_DIR, "index.ts"),
    indexLines.join("\n"),
    "utf-8"
  );

  console.log("Types generated in lib/types/");
}

main().catch((err) => {
  // Make the script fail fast in CI or npm scripts when something goes wrong.
  console.error(err);
  process.exit(1);
});
